<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Volume Calculator</title>
    
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom styles for the 3D preview container (Mobile Friendly) */
        #preview-container {
            width: 100%;
            /* Use aspect ratio for mobile view, ensuring canvas is visible */
            height: 350px; 
            transition: height 0.3s ease-in-out; 
            background-color: #0d1217; 
            border-radius: 0.75rem;
            overflow: hidden;
            touch-action: none; 
            cursor: grab;
            margin-bottom: 1rem;
        }
        #preview-container.enlarged {
            height: 600px; 
        }
        #preview-container:active {
            cursor: grabbing;
        }
        body {
            font-family: 'Inter', sans-serif;
            min-height: 10vh;
        }
        /* Style for the highlighting color */
        .highlight-border {
            border-color: #f97316 !important; /* Orange-600 */
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.5);
        }
    </style>
</head>
<body class="bg-gray-100 flex items-start justify-center p-4 sm:p-8">

    <div class="w-full max-w-5xl bg-white p-6 sm:p-8 rounded-xl shadow-2xl space-y-8">
        <h1 class="text-3xl font-extrabold text-gray-900 text-center border-b pb-4">
            Trapezoidal Prism Volume Calculator
        </h1>

        <!-- 3D Preview Section -->
        <div>
            <h2 class="text-xl font-semibold mb-3 text-gray-700">3D Skeleton Preview (Flipped Orientation)</h2>
            <div id="preview-container">
                <!-- Three.js Canvas will be appended here -->
            </div>
            
            <!-- Preview Controls -->
            <div class="flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 sm:space-x-4 p-4 bg-gray-50 rounded-lg shadow-inner">
                
                <!-- Zoom Control -->
                <div class="w-full sm:w-1/2">
                    <label for="zoomSlider" class="block text-sm font-medium text-gray-700 mb-1">Zoom/Camera Distance</label>
                    <input type="range" id="zoomSlider" min="10" max="50" value="25" step="1"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-sm"
                           oninput="updateZoom(this.value)">
                </div>
                
                <!-- Enlarge Toggle -->
                <div class="w-full sm:w-1/2 flex justify-end">
                    <button id="toggleCanvasButton" onclick="toggleCanvasSize()"
                            class="w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 transition duration-150 shadow-md">
                        Enlarge View
                    </button>
                </div>
            </div>
        </div>

        <!-- Inputs and Calculation Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Parameter Inputs -->
            <div class="space-y-4">
                <h2 class="text-xl font-semibold text-gray-700">Dimensions (L, B, H₁, H₂)</h2>
                <p class="text-sm text-gray-500">
                    *H₁ can be 0 (Triangular Prism). Clamping (min=0.1) applies only to geometry for stability, not input fields.
                </p>

                <!-- L Input (Length of the prism, along the channel) -->
                <div class="flex flex-col">
                    <label for="inputL" class="text-sm font-medium text-gray-600">Length (L)</label>
                    <input type="number" id="inputL" value="10.5" step="any"
                           onfocus="highlightDimension('L')" onblur="highlightDimension(null)"
                           class="mt-1 p-2 border border-gray-300 rounded-lg focus:ring-orange-500 focus:border-orange-500 shadow-sm">
                </div>

                <!-- B Input (Breadth/Base width of trapezoid) -->
                <div class="flex flex-col">
                    <label for="inputB" class="text-sm font-medium text-gray-600">Breadth (B)</label>
                    <input type="number" id="inputB" value="5.2" step="any"
                           onfocus="highlightDimension('B')" onblur="highlightDimension(null)"
                           class="mt-1 p-2 border border-gray-300 rounded-lg focus:ring-orange-500 focus:border-orange-500 shadow-sm">
                </div>

                <!-- H1 Input (Shorter Vertical Height) -->
                <div class="flex flex-col">
                    <label for="inputH1" class="text-sm font-medium text-gray-600">Height 1 (H₁)</label>
                    <input type="number" id="inputH1" value="3.1" step="any"
                           onfocus="highlightDimension('H1')" onblur="highlightDimension(null)"
                           class="mt-1 p-2 border border-gray-300 rounded-lg focus:ring-orange-500 focus:border-orange-500 shadow-sm">
                </div>

                <!-- H2 Input (Taller Vertical Height) -->
                <div class="flex flex-col">
                    <label for="inputH2" class="text-sm font-medium text-gray-600">Height 2 (H₂)</label>
                    <input type="number" id="inputH2" value="8.3" step="any"
                           onfocus="highlightDimension('H2')" onblur="highlightDimension(null)"
                           class="mt-1 p-2 border border-gray-300 rounded-lg focus:ring-orange-500 focus:border-orange-500 shadow-sm">
                </div>
                
                <!-- CALCULATE BUTTON -->
                <button onclick="updateVolumeAndShape(null)"
                        class="w-full px-6 py-3 mt-4 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition duration-150 shadow-lg text-lg">
                    Calculate Volume & Update 3D
                </button>
            </div>

            <!-- Result and Formula Display -->
            <div class="space-y-6 bg-blue-50 p-6 rounded-lg shadow-inner border border-blue-200 self-start">
                <h2 class="text-xl font-semibold text-blue-800">Calculated Volume</h2>
                <div class="text-4xl font-bold text-blue-700">
                    <span id="volumeResult">0.0000</span> units³
                </div>

                <div class="pt-4 border-t border-blue-200">
                    <h3 class="text-lg font-medium text-blue-800 mb-2">Formula Used</h3>
                    <div class="bg-white p-3 rounded-md border border-gray-300 text-center font-mono text-gray-800 text-lg">
                        V = L &times; Area<sub>Trapezoid</sub>
                        <br>
                        Area<sub>Trapezoid</sub> = &frac12; &times; B &times; (H₁ + H₂)
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // --- Three.js Setup and Variables ---
        let scene, camera, renderer, prismGroup;
        let container = document.getElementById('preview-container');
        let zoomSlider = document.getElementById('zoomSlider');
        // Minimum dimension for L, B, H2 to prevent collapse. H1 can be 0.
        const minDimension = 0.1; 

        // Colors and Materials
        const DEFAULT_COLOR = 0xeeeeee;
        const HIGHLIGHT_COLOR = 0xf97316; // Orange-600
        const DEFAULT_LINE_WIDTH = 2;
        const HIGHLIGHT_LINE_WIDTH = 4;

        // --- Mouse/Touch Rotation Variables ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const rotationSpeed = 0.005;
        let cameraDistance = parseFloat(zoomSlider.value);


        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d1217);

            // Camera setup - positioned far back initially, adjusted by zoom slider
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(cameraDistance, cameraDistance, cameraDistance);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Group to hold the shape, allowing easy rotation
            prismGroup = new THREE.Group();
            scene.add(prismGroup);
            
            // --- MODIFIED INITIAL ROTATION FOR UPSIDE DOWN VIEW ---
            // 1. Flip 180 degrees around the X-axis (Math.PI) to invert the shape visually.
            // 2. Change the Y-axis rotation to -45 degrees (-Math.PI / 4).
            prismGroup.rotation.x = Math.PI; 
            prismGroup.rotation.y = -Math.PI / 4; 
            
            createSkeleton();

            // Setup Event Listeners for Rotation
            container.addEventListener('mousedown', onMouseDown);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('mouseup', onMouseUp);
            container.addEventListener('touchstart', onTouchStart, { passive: false });
            container.addEventListener('touchmove', onTouchMove, { passive: false });
            container.addEventListener('touchend', onTouchEnd);

            // Handle resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- View Control Functions ---
        
        window.updateZoom = function(distance) {
            cameraDistance = parseFloat(distance);
            // Re-calculate the camera position based on current angle and new distance
            const currentPosition = camera.position.clone().normalize();
            camera.position.copy(currentPosition.multiplyScalar(cameraDistance));
            camera.lookAt(0, 0, 0);
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
        }

        window.toggleCanvasSize = function() {
            const isEnlarged = container.classList.toggle('enlarged');
            const button = document.getElementById('toggleCanvasButton');
            
            if (isEnlarged) {
                button.textContent = 'Shrink View';
            } else {
                button.textContent = 'Enlarge View';
            }
            
            // Wait for CSS transition (0.3s) before resizing the renderer
            setTimeout(onWindowResize, 350);
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.render(scene, camera);
        }
        
        // --- Rotation Handlers (Turntable: Y-Axis Only) ---
        
        function getClientCoords(event) {
            if (event.touches) {
                return { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
            return { x: event.clientX, y: event.clientY };
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = getClientCoords(event);
        }

        function onMouseMove(event) {
            if (!isDragging) return;
            event.preventDefault(); 
            const currentPosition = getClientCoords(event);
            const deltaX = currentPosition.x - previousMousePosition.x;
            // Vertical movement ignored for Turntable (Y-axis rotation only)

            // Apply rotation only around the Y-axis (vertical turntable spin)
            if (prismGroup) {
                prismGroup.rotation.y += deltaX * rotationSpeed;
            }

            previousMousePosition = currentPosition;
            renderer.render(scene, camera);
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                onMouseDown(event);
            }
        }

        function onTouchMove(event) {
             if (event.touches.length === 1) {
                event.preventDefault();
                onMouseMove(event);
            }
        }

        function onTouchEnd() {
            onMouseUp();
        }

        // --- Core Calculation and Geometry Functions ---

        /**
         * Calculates the volume, but only clamps values used for the 3D model geometry.
         * Input fields are NOT overwritten.
         */
        function calculateAndClamp(L_in, B_in, H1_in, H2_in) {
            // Parse inputs (allowing full user input, including decimals)
            const L_val = parseFloat(L_in) || 0;
            const B_val = parseFloat(B_in) || 0;
            const H1_val = parseFloat(H1_in) || 0;
            const H2_val = parseFloat(H2_in) || 0;

            // Clamping for Geometry (L, B, H2 must be > 0.1 for Three.js stability)
            let L_geom = Math.max(minDimension, L_val);
            let B_geom = Math.max(minDimension, B_val);
            let H1_geom = Math.max(0, H1_val); // H1 allowed to be 0
            let H2_geom = Math.max(minDimension, H2_val);

            // Volume calculation uses the full user-inputted values (L_val, B_val, etc.)
            // If any value is 0, the volume will correctly be 0.
            const volume = L_val * 0.5 * B_val * (H1_val + H2_val);
            
            return { L: L_geom, B: B_geom, H1: H1_geom, H2: H2_geom, volume };
        }

        /**
         * Creates a line segment between two points.
         */
        function makeLine(v1, v2, material) {
            const geometry = new THREE.BufferGeometry().setFromPoints([v1, v2]);
            return new THREE.LineSegments(geometry, material); 
        }

        /**
         * Creates the entire skeleton shape by defining all 12 edges with correct dimension mapping.
         * Uses clamped values (L, B, H1, H2) for stability.
         */
        function createSkeleton(highlightedDimension = null) {
            const { L, B, H1, H2 } = calculateAndClamp(
                document.getElementById('inputL').value,
                document.getElementById('inputB').value,
                document.getElementById('inputH1').value,
                document.getElementById('inputH2').value
            );

            // Clear previous geometry
            while(prismGroup.children.length > 0){
                prismGroup.remove(prismGroup.children[0]);
            }

            // The shape is defined upright (0 at bottom, maxH at top).
            const maxH = Math.max(H1, H2, minDimension);
            const centerOffset = maxH / 2;
            const positionCorrection = new THREE.Vector3(0, -centerOffset, 0);

            // Define Vertices (Trapezoid in X-Y plane, L along Z)
            const V = {
                // Front Face (Z = L/2) - Base at Y=0
                V0: new THREE.Vector3(-B/2, 0, L/2).add(positionCorrection),    // Bottom Left (H=0)
                V1: new THREE.Vector3(B/2, 0, L/2).add(positionCorrection),     // Bottom Right (H=0)
                V4: new THREE.Vector3(-B/2, H1, L/2).add(positionCorrection),   // Top Left (H=H1)
                V5: new THREE.Vector3(B/2, H2, L/2).add(positionCorrection),    // Top Right (H=H2)

                // Back Face (Z = -L/2) - Base at Y=0
                V3: new THREE.Vector3(-B/2, 0, -L/2).add(positionCorrection),   // Bottom Left (H=0)
                V2: new THREE.Vector3(B/2, 0, -L/2).add(positionCorrection),    // Bottom Right (H=0)
                V7: new THREE.Vector3(-B/2, H1, -L/2).add(positionCorrection),  // Top Left (H=H1)
                V6: new THREE.Vector3(B/2, H2, -L/2).add(positionCorrection),   // Top Right (H=H2)
            };

            // Define materials
            const defaultMat = new THREE.LineBasicMaterial({ color: DEFAULT_COLOR, linewidth: DEFAULT_LINE_WIDTH });
            const highlightMat = new THREE.LineBasicMaterial({ color: HIGHLIGHT_COLOR, linewidth: HIGHLIGHT_LINE_WIDTH });

            // Define all 12 edges and their corresponding dimension property
            const edges = [
                // 1. Length (L) Edges (parallel to Z-axis) - 4 lines
                { v1: V.V0, v2: V.V3, dim: 'L' }, // Bottom Left
                { v1: V.V1, v2: V.V2, dim: 'L' }, // Bottom Right
                { v1: V.V4, v2: V.V7, dim: 'L' }, // Top Left (H1)
                { v1: V.V5, v2: V.V6, dim: 'L' }, // Top Right (H2)

                // 2. Breadth (B) Edges (parallel to X-axis, on the base) - 2 lines
                { v1: V.V0, v2: V.V1, dim: 'B' }, // Bottom Front Base
                { v1: V.V3, v2: V.V2, dim: 'B' }, // Bottom Back Base
                
                // 3. Sloped/Top Edges (derived/no highlight) - 2 lines
                { v1: V.V4, v2: V.V5, dim: 'SLOPE' }, // Top Front Sloped Edge (NOT B)
                { v1: V.V7, v2: V.V6, dim: 'SLOPE' }, // Top Back Sloped Edge (NOT B)

                // 4. Height 1 (H1) Edges (parallel to Y-axis) - 2 lines
                { v1: V.V0, v2: V.V4, dim: 'H1' }, // Front Left Vertical
                { v1: V.V3, v2: V.V7, dim: 'H1' }, // Back Left Vertical

                // 5. Height 2 (H2) Edges (parallel to Y-axis) - 2 lines
                { v1: V.V1, v2: V.V5, dim: 'H2' }, // Front Right Vertical
                { v1: V.V2, v2: V.V6, dim: 'H2' }, // Back Right Vertical
            ];

            // Add lines to the group
            edges.forEach(edge => {
                // Only highlight if the dimension matches and it's not a derived 'SLOPE'
                const material = (edge.dim === highlightedDimension && edge.dim !== 'SLOPE') ? highlightMat : defaultMat;
                const line = makeLine(edge.v1, edge.v2, material);
                prismGroup.add(line);
            });
            
            // Adjust camera position based on the size of the shape
            const size = Math.max(L, B, maxH, 10);
            camera.position.setLength(cameraDistance * size / 10);
            camera.lookAt(0, 0, 0);

            // Render the new skeleton immediately
            renderer.render(scene, camera);
        }

        /**
         * Main function to be called on button click.
         */
        window.updateVolumeAndShape = function(highlightedDimension) {
            // Get values from inputs
            const L_in = document.getElementById('inputL').value;
            const B_in = document.getElementById('inputB').value;
            const H1_in = document.getElementById('inputH1').value;
            const H2_in = document.getElementById('inputH2').value;

            // 1. Calculate volume (uses precise input values)
            const { volume } = calculateAndClamp(L_in, B_in, H1_in, H2_in);
            
            // Display result with high precision (4 decimal places)
            document.getElementById('volumeResult').textContent = volume.toFixed(4);

            // 2. Update 3D Shape (uses clamped geometry values)
            createSkeleton(highlightedDimension);
        }

        /**
         * Highlights the dimension when the input box is focused or blurs (onfocus/onblur).
         */
        window.highlightDimension = function(dimension) {
            // Add/Remove highlight border on the input element
            document.querySelectorAll('input[type="number"]').forEach(input => {
                const dimId = input.id.replace('input', ''); 
                
                if (dimId === dimension) {
                    input.classList.add('highlight-border');
                } else {
                    input.classList.remove('highlight-border');
                }
            });

            // Recreate the skeleton with the current highlight state (no calculation needed)
            createSkeleton(dimension);
        }

        // Initialize Three.js and start the application
        window.onload = function() {
            initThreeJS();
            updateZoom(zoomSlider.value); 
            // Call updateVolumeAndShape once on load to populate initial values and shape
            updateVolumeAndShape(null); 
            animate(); 
        };

        // The animation loop is kept minimal, only checking for drag events to update the render.
        function animate() {
            requestAnimationFrame(animate);
            // Render is explicitly called on drag or button click/highlight change.
        }

    </script>
</body>
</html>